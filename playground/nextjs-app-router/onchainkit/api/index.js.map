{"version":3,"sources":["../../src/network/definitions/swap.ts","../../src/version.ts","../../src/network/constants.ts","../../src/OnchainKitConfig.ts","../../src/network/getRPCUrl.ts","../../src/network/request.ts","../../src/swap/constants.ts","../../src/swap/utils/getSwapErrorCode.ts","../../src/swap/utils/fromReadableAmount.ts","../../src/swap/utils/toReadableAmount.ts","../../src/swap/utils/formatDecimals.ts","../../src/api/utils/getAPIParamsForToken.ts","../../src/api/utils/getSwapTransaction.ts","../../src/api/buildSwapTransaction.ts","../../src/network/definitions/pay.ts","../../src/checkout/constants.ts","../../src/api/utils/getPayErrorMessage.ts","../../src/api/buildPayTransaction.ts","../../src/api/getSwapQuote.ts","../../src/api/getTokens.ts"],"sourcesContent":["export const CDP_LIST_SWAP_ASSETS = 'cdp_listSwapAssets';\nexport const CDP_GET_SWAP_QUOTE = 'cdp_getSwapQuote';\nexport const CDP_GET_SWAP_TRADE = 'cdp_getSwapTrade';\n","export const version = '0.35.2';\n","import { version } from '../version';\n\nexport const POST_METHOD = 'POST';\nexport const JSON_HEADERS = {\n  'Content-Type': 'application/json',\n  'OnchainKit-Version': version,\n};\nexport const JSON_RPC_VERSION = '2.0';\n","import { baseSepolia } from 'viem/chains';\nimport type { OnchainKitConfig, SetOnchainKitConfig } from './types';\n\n// The ONCHAIN_KIT_CONFIG is not exported at index.ts,\n// but only acccessed through the get and set functions.\nexport const ONCHAIN_KIT_CONFIG: OnchainKitConfig = {\n  address: null,\n  apiKey: null,\n  chain: baseSepolia,\n  config: {\n    appearance: {\n      name: null,\n      logo: null,\n      mode: null,\n      theme: null,\n    },\n    paymaster: null,\n  },\n  rpcUrl: null,\n  schemaId: null,\n  projectId: null,\n};\n\n/**\n * Access the ONCHAIN_KIT_CONFIG object directly by providing the key.\n * This is powerful when you use OnchainKit utilities outside of the React context.\n */\nexport const getOnchainKitConfig = <K extends keyof typeof ONCHAIN_KIT_CONFIG>(\n  configName: K,\n): (typeof ONCHAIN_KIT_CONFIG)[K] => {\n  return ONCHAIN_KIT_CONFIG[configName];\n};\n\n/**\n * Update the ONCHAIN_KIT_CONFIG object directly by providing the properties to update.\n * This is powerful when you use OnchainKit utilities outside of the React context.\n */\nexport const setOnchainKitConfig = (properties: SetOnchainKitConfig) => {\n  Object.assign(ONCHAIN_KIT_CONFIG, properties);\n  return getOnchainKitConfig;\n};\n","import { ONCHAIN_KIT_CONFIG } from '../OnchainKitConfig';\n\n/**\n * Access the RPC URL for OnchainKit.\n * Defaults to using Coinbase Developer Platform if a RPC URL is not provided.\n */\nexport const getRPCUrl = () => {\n  if (!ONCHAIN_KIT_CONFIG.rpcUrl && !ONCHAIN_KIT_CONFIG.apiKey) {\n    throw new Error(\n      'API Key Unset: You can use the Coinbase Developer Platform RPC by providing an API key in `OnchainKitProvider` or by manually calling `setOnchainKitConfig`: https://portal.cdp.coinbase.com/products/onchainkit',\n    );\n  }\n  return (\n    ONCHAIN_KIT_CONFIG.rpcUrl ||\n    `https://api.developer.coinbase.com/rpc/v1/${ONCHAIN_KIT_CONFIG.chain.name.replace(' ', '-').toLowerCase()}/${ONCHAIN_KIT_CONFIG.apiKey}`\n  );\n};\n","import { JSON_HEADERS, JSON_RPC_VERSION, POST_METHOD } from './constants';\nimport { getRPCUrl } from './getRPCUrl';\n\nexport type JSONRPCError = {\n  code: number;\n  message: string;\n};\n\nexport type JSONRPCRequest<T> = {\n  id: number;\n  jsonrpc: string;\n  method: string;\n  params: T[];\n};\n\nexport type JSONRPCResult<T> = {\n  error?: JSONRPCError;\n  id: number;\n  jsonrpc: string;\n  result: T;\n};\n\n/**\n * Builds a JSON-RPC request body.\n *\n * @param method - The method name.\n * @param params - The parameters for the method.\n * @returns The JSON-RPC request body.\n * @template T - The type of the parameters.\n */\nexport function buildRequestBody<T>(\n  method: string,\n  params: T[],\n): JSONRPCRequest<T> {\n  return {\n    id: 1,\n    jsonrpc: JSON_RPC_VERSION,\n    method: method,\n    params: params,\n  };\n}\n\n/**\n * Sends a JSON-RPC request to configured RPC URL.\n * Defaults to using the Coinbase Developer Platform Node.\n *\n * @param body - The JSON-RPC request body.\n * @returns A promise that resolves to the JSON-RPC response.\n * @throws If an error occurs while sending the request.\n */\nexport async function sendRequest<T, V>(\n  method: string,\n  params: T[],\n): Promise<JSONRPCResult<V>> {\n  try {\n    const body = buildRequestBody<T>(method, params);\n    const url = getRPCUrl();\n    const response = await fetch(url, {\n      body: JSON.stringify(body),\n      headers: JSON_HEADERS,\n      method: POST_METHOD,\n    });\n    const data: JSONRPCResult<V> = await response.json();\n    return data;\n  } catch (error) {\n    console.log(\n      `sendRequest: error sending request: ${(error as Error).message}`,\n    );\n    throw error;\n  }\n}\n","export const FALLBACK_DEFAULT_MAX_SLIPPAGE = 3;\nexport const GENERAL_SWAP_ERROR_CODE = 'SWAP_ERROR';\nexport const GENERAL_SWAP_QUOTE_ERROR_CODE = 'SWAP_QUOTE_ERROR';\nexport const GENERAL_SWAP_BALANCE_ERROR_CODE = 'SWAP_BALANCE_ERROR';\nexport const LOW_LIQUIDITY_ERROR_CODE = 'SWAP_QUOTE_LOW_LIQUIDITY_ERROR';\nexport const PERMIT2_CONTRACT_ADDRESS =\n  '0x000000000022D473030F116dDEE9F6B43aC78BA3';\nexport const TOO_MANY_REQUESTS_ERROR_CODE = 'TOO_MANY_REQUESTS_ERROR';\nexport const UNCAUGHT_SWAP_QUOTE_ERROR_CODE = 'UNCAUGHT_SWAP_QUOTE_ERROR';\nexport const UNCAUGHT_SWAP_ERROR_CODE = 'UNCAUGHT_SWAP_ERROR';\nexport const UNIVERSALROUTER_CONTRACT_ADDRESS =\n  '0x3fC91A3afd70395Cd496C647d5a6CC9D4B2b7FAD';\nexport const USER_REJECTED_ERROR_CODE = 'USER_REJECTED';\nexport enum SwapMessage {\n  BALANCE_ERROR = 'Error fetching token balance',\n  CONFIRM_IN_WALLET = 'Confirm in wallet',\n  FETCHING_QUOTE = 'Fetching quote...',\n  FETCHING_BALANCE = 'Fetching balance...',\n  INCOMPLETE_FIELD = 'Complete the fields to continue',\n  INSUFFICIENT_BALANCE = 'Insufficient balance',\n  LOW_LIQUIDITY = 'Insufficient liquidity for this trade.',\n  SWAP_IN_PROGRESS = 'Swap in progress...',\n  TOO_MANY_REQUESTS = 'Too many requests. Please try again later.',\n  USER_REJECTED = 'User rejected the transaction',\n}\n","import {\n  GENERAL_SWAP_BALANCE_ERROR_CODE,\n  GENERAL_SWAP_ERROR_CODE,\n  GENERAL_SWAP_QUOTE_ERROR_CODE,\n  LOW_LIQUIDITY_ERROR_CODE,\n  TOO_MANY_REQUESTS_ERROR_CODE,\n  UNCAUGHT_SWAP_ERROR_CODE,\n  UNCAUGHT_SWAP_QUOTE_ERROR_CODE,\n} from '../constants';\n\nexport function getSwapErrorCode(\n  context: 'swap' | 'quote' | 'balance' | 'uncaught-swap' | 'uncaught-quote',\n  errorCode?: number,\n) {\n  // TODO: handle additional error codes\n  if (errorCode === -32001) {\n    return TOO_MANY_REQUESTS_ERROR_CODE;\n  }\n\n  if (errorCode === -32602) {\n    return LOW_LIQUIDITY_ERROR_CODE;\n  }\n\n  if (context === 'uncaught-swap') {\n    return UNCAUGHT_SWAP_ERROR_CODE;\n  }\n\n  if (context === 'uncaught-quote') {\n    return UNCAUGHT_SWAP_QUOTE_ERROR_CODE;\n  }\n\n  if (context === 'quote') {\n    return GENERAL_SWAP_QUOTE_ERROR_CODE;\n  }\n\n  if (context === 'balance') {\n    return GENERAL_SWAP_BALANCE_ERROR_CODE;\n  }\n\n  return GENERAL_SWAP_ERROR_CODE;\n}\n","export function fromReadableAmount(amount: string, decimals: number): string {\n  const [wholePart, fractionalPart = ''] = amount.split('.');\n  const paddedFractionalPart = fractionalPart.padEnd(decimals, '0');\n  const trimmedFractionalPart = paddedFractionalPart.slice(0, decimals);\n  return (\n    BigInt(wholePart + trimmedFractionalPart) *\n    BigInt(10) ** BigInt(decimals - trimmedFractionalPart.length)\n  ).toString();\n}\n","export function toReadableAmount(amount: string, decimals: number): string {\n  // Check if the amount contains a decimal point\n  if (amount.includes('.')) {\n    const [wholePart, fractionalPart] = amount.split('.');\n    const paddedFractionalPart = fractionalPart.padEnd(decimals, '0');\n    const combinedAmount = wholePart + paddedFractionalPart;\n    return combinedAmount;\n  }\n\n  // If no decimal point, proceed with the original logic\n  const bigIntAmount = BigInt(amount);\n  const divisor = BigInt(10) ** BigInt(decimals);\n  const wholePart = (bigIntAmount / divisor).toString();\n  const fractionalPart = (bigIntAmount % divisor)\n    .toString()\n    .padStart(decimals, '0');\n  const trimmedFractionalPart = fractionalPart.replace(/0+$/, '');\n  return trimmedFractionalPart\n    ? `${wholePart}.${trimmedFractionalPart}`\n    : wholePart;\n}\n","import { fromReadableAmount } from './fromReadableAmount';\nimport { toReadableAmount } from './toReadableAmount';\n\n/**\n * Formats an amount according to the decimals. Defaults to 18 decimals for ERC-20s.\n */\nexport function formatDecimals(\n  amount: string,\n  inputInDecimals = true,\n  decimals = 18,\n): string {\n  let result: string;\n\n  if (inputInDecimals) {\n    // If input is already in decimals, convert to readable amount\n    result = toReadableAmount(amount, decimals);\n  } else {\n    // If input is not in decimals, convert from readable amount\n    result = fromReadableAmount(amount, decimals);\n  }\n\n  return result;\n}\n","import { formatDecimals } from '../../swap/utils/formatDecimals';\nimport type {\n  APIError,\n  BuildSwapTransactionParams,\n  GetAPIParamsForToken,\n  SwapAPIParams,\n} from '../types';\n\n/**\n * Converts parameters with `Token` to ones with address.\n *\n * Additionally adds default values for optional request fields.\n */\nexport function getAPIParamsForToken(\n  params: GetAPIParamsForToken,\n): SwapAPIParams | APIError {\n  const { from, to, amount, amountReference, isAmountInDecimals } = params;\n  const { fromAddress } = params as BuildSwapTransactionParams;\n  const decimals = amountReference === 'from' ? from.decimals : to.decimals;\n\n  // Input validation\n  if (typeof amount !== 'string' || amount.trim() === '') {\n    return {\n      code: 'INVALID_INPUT',\n      error: 'Invalid input: amount must be a non-empty string',\n      message: '',\n    };\n  }\n  if (!Number.isInteger(decimals) || decimals < 0) {\n    return {\n      code: 'INVALID_INPUT',\n      error: 'Invalid input: decimals must be a non-negative integer',\n      message: '',\n    };\n  }\n  if (!/^(?:0|[1-9]\\d*|\\.\\d+)(?:\\.\\d*)?$/.test(amount)) {\n    return {\n      code: 'INVALID_INPUT',\n      error: 'Invalid input: amount must be a non-negative number string',\n      message: '',\n    };\n  }\n\n  return {\n    fromAddress: fromAddress,\n    from: from.address || 'ETH',\n    to: to.address || 'ETH',\n    amount: isAmountInDecimals\n      ? amount\n      : formatDecimals(amount, false, decimals),\n    amountReference: amountReference || 'from',\n  };\n}\n","import type { Address, Hex } from 'viem';\nimport type { Transaction } from '../../swap/types';\nimport type { RawTransactionData } from '../types';\n\n/**\n * Constructs an unsigned transaction.\n *\n * A transaction is a message sent by an Account requesting\n * to perform an action on the Ethereum blockchain.\n *\n * Transactions can be used to transfer Ether between accounts,\n * execute smart contract code, deploy smart contracts, etc.\n */\nexport function getSwapTransaction(\n  rawTx: RawTransactionData,\n  chainId: string,\n): Transaction {\n  const { data, gas, to, value } = rawTx;\n  return {\n    chainId: Number(chainId),\n    data: data as Hex,\n    gas: BigInt(gas),\n    to: to as Address,\n    value: BigInt(value),\n  };\n}\n","import { CDP_GET_SWAP_TRADE } from '../network/definitions/swap';\nimport { sendRequest } from '../network/request';\nimport type { SwapAPIResponse } from '../swap/types';\nimport { getSwapErrorCode } from '../swap/utils/getSwapErrorCode';\nimport type {\n  APIError,\n  BuildSwapTransactionParams,\n  BuildSwapTransactionResponse,\n  SwapAPIParams,\n} from './types';\nimport { getAPIParamsForToken } from './utils/getAPIParamsForToken';\nimport { getSwapTransaction } from './utils/getSwapTransaction';\n\n/**\n * Retrieves an unsigned transaction for a swap from Token A to Token B.\n */\nexport async function buildSwapTransaction(\n  params: BuildSwapTransactionParams,\n): Promise<BuildSwapTransactionResponse> {\n  // Default parameters\n  const defaultParams = {\n    amountReference: 'from',\n    isAmountInDecimals: false,\n  };\n\n  const apiParamsOrError = getAPIParamsForToken({\n    ...defaultParams,\n    ...params,\n  });\n  if ((apiParamsOrError as APIError).error) {\n    return apiParamsOrError as APIError;\n  }\n  let apiParams = apiParamsOrError as SwapAPIParams;\n\n  if (!params.useAggregator) {\n    apiParams = {\n      v2Enabled: true,\n      ...apiParams,\n    };\n  }\n  if (params.maxSlippage) {\n    let slippagePercentage = params.maxSlippage;\n    // Adjust slippage for V1 API (aggregator)\n    // V1 expects slippage in tenths of a percent (e.g., 30 = 3%)\n    if (params.useAggregator) {\n      slippagePercentage = (Number(params.maxSlippage) * 10).toString();\n    }\n    apiParams = {\n      slippagePercentage,\n      ...apiParams,\n    };\n  }\n\n  try {\n    const res = await sendRequest<SwapAPIParams, SwapAPIResponse>(\n      CDP_GET_SWAP_TRADE,\n      [apiParams],\n    );\n    if (res.error) {\n      return {\n        code: getSwapErrorCode('swap', res.error?.code),\n        error: res.error.message,\n        message: '',\n      };\n    }\n\n    const trade = res.result;\n    return {\n      approveTransaction: trade.approveTx\n        ? getSwapTransaction(trade.approveTx, trade.chainId)\n        : undefined,\n      fee: trade.fee,\n      quote: trade.quote,\n      transaction: getSwapTransaction(trade.tx, trade.chainId),\n      warning: trade.quote.warning,\n    };\n  } catch (_error) {\n    return {\n      code: getSwapErrorCode('uncaught-swap'),\n      error: 'Something went wrong',\n      message: '',\n    };\n  }\n}\n","export const CDP_HYDRATE_CHARGE = 'cdp_hydrateCharge';\nexport const CDP_CREATE_PRODUCT_CHARGE = 'cdp_createProductCharge';\n","export const GENERAL_CHECKOUT_ERROR_MESSAGE = 'CHECKOUT_ERROR';\nexport const GENERIC_ERROR_MESSAGE = 'Something went wrong. Please try again.';\nexport const NO_CONTRACTS_ERROR = 'Contracts are not available';\nexport const NO_CONNECTED_ADDRESS_ERROR = 'No connected address';\nexport const CHECKOUT_UNSUPPORTED_CHAIN_ERROR_MESSAGE = 'UNSUPPORTED_CHAIN';\nexport const CHECKOUT_TOO_MANY_REQUESTS_ERROR_MESSAGE =\n  'CHECKOUT_TOO_MANY_REQUESTS_ERROR';\n\nexport const CHECKOUT_INSUFFICIENT_BALANCE_ERROR =\n  'User has insufficient balance';\nexport const CHECKOUT_INSUFFICIENT_BALANCE_ERROR_MESSAGE = (\n  priceInUSD: string,\n) => {\n  return `You need at least ${priceInUSD} USDC to continue with payment`;\n};\nexport const CHECKOUT_INVALID_CHARGE_ERROR_MESSAGE =\n  'CHECKOUT_INVALID_CHARGE_ERROR';\nexport const CHECKOUT_INVALID_PARAMETER_ERROR_MESSAGE =\n  'CHECKOUT_INVALID_PARAMETER_ERROR';\nexport const UNCAUGHT_CHECKOUT_ERROR_MESSAGE = 'UNCAUGHT_CHECKOUT_ERROR';\nexport const USER_REJECTED_ERROR = 'Request denied.';\n\nexport enum CheckoutErrorCode {\n  INSUFFICIENT_BALANCE = 'insufficient_balance',\n  GENERIC_ERROR = 'generic_error',\n  UNEXPECTED_ERROR = 'unexpected_error',\n  USER_REJECTED_ERROR = 'user_rejected',\n}\n\nexport interface CheckoutErrorType {\n  code: CheckoutErrorCode;\n  error: string;\n  message: string;\n}\n\nexport type CheckoutErrors = {\n  [K in CheckoutErrorCode]: CheckoutErrorType;\n};\n\nexport enum CHECKOUT_LIFECYCLESTATUS {\n  FETCHING_DATA = 'fetchingData',\n  INIT = 'init',\n  PENDING = 'pending',\n  READY = 'ready',\n  SUCCESS = 'success',\n  ERROR = 'error',\n}\n\nexport const USDC_ADDRESS_BASE = '0x833589fcd6edb6e08f4c7c32d4f71b54bda02913';\n\nexport enum CONTRACT_METHODS {\n  APPROVE = 'approve',\n  BALANCE_OF = 'balanceOf',\n  TRANSFER_TOKEN_PRE_APPROVED = 'transferTokenPreApproved',\n}\n\nexport const COMMERCE_ABI = [\n  {\n    type: 'function',\n    name: 'transferTokenPreApproved',\n    inputs: [\n      {\n        name: '_intent',\n        type: 'tuple',\n        components: [\n          {\n            name: 'recipientAmount',\n            type: 'uint256',\n          },\n          {\n            name: 'deadline',\n            type: 'uint256',\n          },\n          {\n            name: 'recipient',\n            type: 'address',\n          },\n          {\n            name: 'recipientCurrency',\n            type: 'address',\n          },\n          {\n            name: 'refundDestination',\n            type: 'address',\n          },\n          {\n            name: 'feeAmount',\n            type: 'uint256',\n          },\n          {\n            name: 'id',\n            type: 'bytes16',\n          },\n          {\n            name: 'operator',\n            type: 'address',\n          },\n          {\n            name: 'signature',\n            type: 'bytes',\n          },\n          {\n            name: 'prefix',\n            type: 'bytes',\n          },\n        ],\n      },\n    ],\n    outputs: [],\n    stateMutability: 'nonpayable',\n  },\n] as const;\n","import {\n  CHECKOUT_INVALID_CHARGE_ERROR_MESSAGE,\n  CHECKOUT_INVALID_PARAMETER_ERROR_MESSAGE,\n  CHECKOUT_TOO_MANY_REQUESTS_ERROR_MESSAGE,\n  GENERAL_CHECKOUT_ERROR_MESSAGE,\n  UNCAUGHT_CHECKOUT_ERROR_MESSAGE,\n} from '../../checkout/constants';\n\nexport function getPayErrorMessage(errorCode?: number) {\n  if (!errorCode) {\n    return UNCAUGHT_CHECKOUT_ERROR_MESSAGE;\n  }\n\n  if (errorCode === -32001) {\n    return CHECKOUT_TOO_MANY_REQUESTS_ERROR_MESSAGE;\n  }\n\n  if (errorCode === -32601) {\n    return CHECKOUT_INVALID_CHARGE_ERROR_MESSAGE;\n  }\n\n  if (errorCode === -32602) {\n    return CHECKOUT_INVALID_PARAMETER_ERROR_MESSAGE;\n  }\n\n  return GENERAL_CHECKOUT_ERROR_MESSAGE;\n}\n","import {\n  CDP_CREATE_PRODUCT_CHARGE,\n  CDP_HYDRATE_CHARGE,\n} from '../network/definitions/pay';\nimport { type JSONRPCResult, sendRequest } from '../network/request';\nimport type {\n  BuildPayTransactionParams,\n  BuildPayTransactionResponse,\n  CreateProductChargeParams,\n  HydrateChargeAPIParams,\n} from './types';\nimport { getPayErrorMessage } from './utils/getPayErrorMessage';\n\nexport async function buildPayTransaction({\n  address,\n  chargeId,\n  productId,\n}: BuildPayTransactionParams): Promise<BuildPayTransactionResponse> {\n  try {\n    let res: JSONRPCResult<BuildPayTransactionResponse>;\n    if (chargeId) {\n      res = await sendRequest<\n        HydrateChargeAPIParams,\n        BuildPayTransactionResponse\n      >(CDP_HYDRATE_CHARGE, [\n        {\n          sender: address,\n          chargeId,\n        },\n      ]);\n    } else if (productId) {\n      res = await sendRequest<\n        CreateProductChargeParams,\n        BuildPayTransactionResponse\n      >(CDP_CREATE_PRODUCT_CHARGE, [\n        {\n          sender: address,\n          productId,\n        },\n      ]);\n    } else {\n      return {\n        code: 'AmBPTa01', // Api Module Build Pay Transaction Error 01\n        error: 'No chargeId or productId provided',\n        message: getPayErrorMessage(),\n      };\n    }\n    if (res.error) {\n      return {\n        code: 'AmBPTa02', // Api Module Build Pay Transaction Error 02\n        error: res.error.message,\n        message: getPayErrorMessage(res.error?.code),\n      };\n    }\n    return res.result;\n  } catch (_error) {\n    return {\n      code: 'AmBPTa03', // Api Module Build Pay Transaction Error 03\n      error: 'Something went wrong',\n      message: getPayErrorMessage(),\n    };\n  }\n}\n","import { CDP_GET_SWAP_QUOTE } from '../network/definitions/swap';\nimport { sendRequest } from '../network/request';\nimport type { SwapQuote } from '../swap/types';\nimport { getSwapErrorCode } from '../swap/utils/getSwapErrorCode';\nimport type {\n  APIError,\n  GetSwapQuoteParams,\n  GetSwapQuoteResponse,\n  SwapAPIParams,\n} from './types';\nimport { getAPIParamsForToken } from './utils/getAPIParamsForToken';\n\n/**\n * Retrieves a quote for a swap from Token A to Token B.\n */\nexport async function getSwapQuote(\n  params: GetSwapQuoteParams,\n): Promise<GetSwapQuoteResponse> {\n  // Default parameters\n  const defaultParams = {\n    amountReference: 'from',\n    isAmountInDecimals: false,\n  };\n  const apiParamsOrError = getAPIParamsForToken({\n    ...defaultParams,\n    ...params,\n  });\n  if ((apiParamsOrError as APIError).error) {\n    return apiParamsOrError as APIError;\n  }\n  let apiParams = apiParamsOrError as SwapAPIParams;\n\n  if (!params.useAggregator) {\n    apiParams = {\n      v2Enabled: true,\n      ...apiParams,\n    };\n  }\n  if (params.maxSlippage) {\n    let slippagePercentage = params.maxSlippage;\n    // Adjust slippage for V1 API (aggregator)\n    // V1 expects slippage in tenths of a percent (e.g., 30 = 3%)\n    if (params.useAggregator) {\n      slippagePercentage = (Number(params.maxSlippage) * 10).toString();\n    }\n    apiParams = {\n      slippagePercentage: slippagePercentage,\n      ...apiParams,\n    };\n  }\n\n  try {\n    const res = await sendRequest<SwapAPIParams, SwapQuote>(\n      CDP_GET_SWAP_QUOTE,\n      [apiParams],\n    );\n    if (res.error) {\n      return {\n        code: getSwapErrorCode('quote', res.error?.code),\n        error: res.error.message,\n        message: '',\n      };\n    }\n    return res.result;\n  } catch (_error) {\n    return {\n      code: getSwapErrorCode('uncaught-quote'),\n      error: 'Something went wrong',\n      message: '',\n    };\n  }\n}\n","import { CDP_LIST_SWAP_ASSETS } from '../network/definitions/swap';\nimport { sendRequest } from '../network/request';\nimport type { Token } from '../token/types';\nimport type { GetTokensOptions, GetTokensResponse } from './types';\n\n/**\n * Retrieves a list of tokens on Base.\n */\nexport async function getTokens(\n  options?: GetTokensOptions,\n): Promise<GetTokensResponse> {\n  // Default filter values\n  const defaultFilter: GetTokensOptions = {\n    limit: '50',\n    page: '1',\n  };\n  const filters = { ...defaultFilter, ...options };\n\n  try {\n    const res = await sendRequest<GetTokensOptions, Token[]>(\n      CDP_LIST_SWAP_ASSETS,\n      [filters],\n    );\n    if (res.error) {\n      return {\n        code: 'AmGTa01',\n        error: res.error.code.toString(),\n        message: res.error.message,\n      };\n    }\n    return res.result;\n  } catch (error) {\n    return {\n      code: 'AmGTa02', // Api module Get Tokens api Error O2\n      error: JSON.stringify(error),\n      message: 'Request failed',\n    };\n  }\n}\n"],"mappings":"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","names":["CDP_LIST_SWAP_ASSETS","CDP_GET_SWAP_QUOTE","CDP_GET_SWAP_TRADE","version","POST_METHOD","JSON_HEADERS","version","JSON_RPC_VERSION","baseSepolia","ONCHAIN_KIT_CONFIG","address","apiKey","chain","baseSepolia","config","appearance","name","logo","mode","theme","paymaster","rpcUrl","schemaId","projectId","getRPCUrl","ONCHAIN_KIT_CONFIG","rpcUrl","apiKey","Error","chain","name","replace","toLowerCase","buildRequestBody","method","params","id","jsonrpc","JSON_RPC_VERSION","sendRequest","body","url","getRPCUrl","response","fetch","JSON","stringify","headers","JSON_HEADERS","POST_METHOD","data","json","error","console","log","message","GENERAL_SWAP_ERROR_CODE","GENERAL_SWAP_QUOTE_ERROR_CODE","GENERAL_SWAP_BALANCE_ERROR_CODE","LOW_LIQUIDITY_ERROR_CODE","TOO_MANY_REQUESTS_ERROR_CODE","UNCAUGHT_SWAP_QUOTE_ERROR_CODE","UNCAUGHT_SWAP_ERROR_CODE","getSwapErrorCode","context","errorCode","TOO_MANY_REQUESTS_ERROR_CODE","LOW_LIQUIDITY_ERROR_CODE","UNCAUGHT_SWAP_ERROR_CODE","UNCAUGHT_SWAP_QUOTE_ERROR_CODE","GENERAL_SWAP_QUOTE_ERROR_CODE","GENERAL_SWAP_BALANCE_ERROR_CODE","GENERAL_SWAP_ERROR_CODE","fromReadableAmount","amount","decimals","wholePart","fractionalPart","split","paddedFractionalPart","padEnd","trimmedFractionalPart","slice","BigInt","length","toString","toReadableAmount","amount","decimals","includes","wholePart","fractionalPart","split","paddedFractionalPart","padEnd","combinedAmount","bigIntAmount","BigInt","divisor","toString","padStart","trimmedFractionalPart","replace","formatDecimals","amount","inputInDecimals","decimals","result","toReadableAmount","fromReadableAmount","getAPIParamsForToken","params","from","to","amount","amountReference","isAmountInDecimals","fromAddress","decimals","trim","code","error","message","Number","isInteger","test","address","formatDecimals","getSwapTransaction","rawTx","chainId","data","gas","to","value","Number","BigInt","buildSwapTransaction","params","defaultParams","amountReference","isAmountInDecimals","apiParamsOrError","getAPIParamsForToken","error","apiParams","useAggregator","v2Enabled","maxSlippage","slippagePercentage","Number","toString","res","sendRequest","CDP_GET_SWAP_TRADE","code","getSwapErrorCode","message","trade","result","approveTransaction","approveTx","getSwapTransaction","chainId","undefined","fee","quote","transaction","tx","warning","_error","CDP_HYDRATE_CHARGE","CDP_CREATE_PRODUCT_CHARGE","GENERAL_CHECKOUT_ERROR_MESSAGE","CHECKOUT_TOO_MANY_REQUESTS_ERROR_MESSAGE","CHECKOUT_INVALID_CHARGE_ERROR_MESSAGE","CHECKOUT_INVALID_PARAMETER_ERROR_MESSAGE","UNCAUGHT_CHECKOUT_ERROR_MESSAGE","getPayErrorMessage","errorCode","UNCAUGHT_CHECKOUT_ERROR_MESSAGE","CHECKOUT_TOO_MANY_REQUESTS_ERROR_MESSAGE","CHECKOUT_INVALID_CHARGE_ERROR_MESSAGE","CHECKOUT_INVALID_PARAMETER_ERROR_MESSAGE","GENERAL_CHECKOUT_ERROR_MESSAGE","buildPayTransaction","address","chargeId","productId","res","sendRequest","CDP_HYDRATE_CHARGE","sender","CDP_CREATE_PRODUCT_CHARGE","code","error","message","getPayErrorMessage","result","_error","getSwapQuote","params","defaultParams","amountReference","isAmountInDecimals","apiParamsOrError","getAPIParamsForToken","error","apiParams","useAggregator","v2Enabled","maxSlippage","slippagePercentage","Number","toString","res","sendRequest","CDP_GET_SWAP_QUOTE","code","getSwapErrorCode","message","result","_error","getTokens","options","defaultFilter","limit","page","filters","res","sendRequest","CDP_LIST_SWAP_ASSETS","error","code","toString","message","result","JSON","stringify"]}